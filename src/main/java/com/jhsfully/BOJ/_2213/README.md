### 2213번 : 트리의 독립집합 [GOLD1]

### 결과
- 시도횟수 : 3회 (2회 => 틀렸습니다)
- 언어: Java8
- 메모리: 31516 KB
- 시간: 664 ms

### 접근 방법 및 풀이
- 문제 제목에서도 확인할 수 있듯이 Tree가 메인이며, 이는 그래프 탐색에 대한 문제임을 알 수 있습니다.
- 사실 이 문제는 Tree의 특징을 잘 이해하고 있어야 쉽게 풀 수 있는 문제이기도 합니다.
- Tree는 비순환 그래프이므로 어느 특정 정점을 Root로 지정한다면, 이를 기준으로 Tree를 형성할 수 있습니다.
- 또한, 비순환 그래프이므로, 특정 부모에서 특정 자식으로 가는 길은 오직 하나의 길만 있어야 합니다.
- 만약 특정 부모에서 특정 자식으로 가는 길이 여러개가 존재할 경우 이는 Tree구조를 어기게 됩니다.
- 만약 부모에서 자식으로 N개의 길로 갈라지게 된다면, 서로 나누어진 N개의 길은 독립적이며 서로 만나서는 안됩니다. 이는 Tree에 구조에 의해 반드시 지켜집니다.
- 이런 특징을 사용한다면, 현재 노드를 선택한 경우, 선택하지 않는 경우 2가지의 경우로 나누어서 문제를 풀어낼 수 있습니다.
- 2가지의 정보를 기록하기 위해서 DP기법을 사용하려고 합니다. Leaf 노드에서는 자신을 선택한 경우, 선택하지 않은 경우를 바로 계산할 수 있기에,
- DFS + DP 방식을 사용할 수 있게됩니다. Leaf노드에서는 선택된 경우는 Weight에서 값을 가져오고, 선택되지 않으면, 0을 설정해주면 됩니다.
- 그리고 DP[node][0]는 현재 노드를 선택하지 않고 얻을 수 있는 최고의 경우의 수 이므로, 자식 정점에서 나올 수 있는 최고의 경우를 더해주면 됩니다..
- DP[node][1]은 현재 노드를 선택하고 얻을 수 있는 최고의 경우이므로, 자식 정점을 선택하지 않았을 때 나올 수 있는 최고의 경우를 더해주면 됩니다.
- 이렇게 하면, max(DP[node][0], DP[node][1])이 가중치의 최고 합산이 될 수 있습니다.
- 그 다음 문제는 경로를 출력해야 한다는 것입니다. DFS + DP문제는 현재 시점을 계산 하기 위해서 미래의 데이터를 가져오게 됩니다.
- 그래서 경로를 계산하는데는 적합하지 않습니다. 역연산에서 경로를 계산하게 된다면, 각 경우 마다의 그래프 상태를 가져와 추가해야하기 때문입니다.
- 이런 경우는 수많은 공간 복잡도와 시간 복잡도를 잡아먹기 때문에 지양해야하는 바입니다.
- 경로 탐색은 역연산이 아닌, 정연산으로 순서대로 탐색하는 것이, 시간 및 공간 복잡도에 매우 유리합니다.
- 그런 이유로 경로를 찾는 함수를 만들어, 기존에 계산해두었던 DP[node][1], DP[node][0] 값을 비교하여, 현재 노드를 선택한 경우가 클 때만 경로에 추가해줍니다.
- 하지만 여기서도 주의해야 할 점이 존재하는데, 현재 노드가 선택되면, 그 다음 노드의 [1]번 값이 크더라도 선택될 수 없게 만들어야 합니다.
- 그래서 경로를 구할 때는 부모의 정점이 선택되었는지 판별하는 boolean변수를 입력받아서 이를 구별해줄 수 있도록 처리해주었습니다.
- 이로써 성공적으로 문제를 풀 수 있었습니다.

### 문제
https://www.acmicpc.net/problem/2213