### 11066번 : 파일 합치기 [GOLD3]

### 문제 유형
- DP (Dynamic Programming)

### 결과
- 시도횟수: 1회
- 언어: Java8
- 메모리: 58968 KB
- 시간: 1076 ms

### 문제 접근 및 풀이
- 소설 파일을 연속적이게 각각 합쳐서, 최종적으로 합치는데 소비한 비용을 줄이는 것이 목표입니다.
- 한 줄에 최대 500개의 연속적인 파일의 입력이 들어올 수 있습니다. DFS탐색으로 모든 경우를 살펴볼 경우,
- 한 깊이 탐색하는데 500가지의 경우, 이것을 끝까지 500의 깊이를 반복하므로, 500^500 정도의 말이 안되는 경우의 수가 나오게 됩니다.
- 이는 연산이 힘듭니다. 하지만, 잘 살펴보면, 완탐을 진행하는데, 이미 계산했던 부분을 꽤나 많이 중복적으로 재계산하는 것을 확인할 수 있었습니다.
- 그렇기에, 이는 DP방식으로 풀이가 된다는 것을 깨달았습니다.
- DP[i][j] 변수를 i에서 j번까지의 파일을 합한 최소비용이라고 가정하고, 가장 인접한 칸부터 차근 차근 계산하여, DP[0][N-1]을 반환하도록 구상하였지만,
- 원하는 결괏값을 얻어낼 수 없었습니다. 왜 이런 결과가 나올까 고민을 해보았는데, 사실 알고보니 DP에 파일을 합한 최소비용 아닌, 파일의 합을 저장하고 있었습니다.
- 하지만 DP에 파일을 합한 최소비용을 저장하려면, 해당 파일을 만드는데 들었던 비용의 기록이 존재하고, 현재 파일의 용량도 가지고 있어야 합니다.
- 현재 파일을 용량은 지금 당장의 파일 합산 비용을 계산하기 위함이고, 해당 파일을 만드는데 들었던 비용은, 비용이 계속 누적되어 합산되기에 기록이 필요합니다.
- 그래서, DP[i][j][0]을 현재 파일의 용량, DP[i][j][1]을 i~j 파일을 합산하는데 든 최소비용을 저장하기로 하였습니다.
- 현재 최소 비용을 계산할 때는, 각각 파일의 용량의 합과, 각각 파일을 만드는데 지금까지 들었던 비용을 합산하여 계산해서 문제를 풀 수 있었습니다.
- 단순한 합산이 아닌, 지금까지 파일을 합치는데 들었던 비용을 기록하고, 재사용한다는 것을 깨달았다면, 문제를 풀 수 있습니다.

### 문제
https://www.acmicpc.net/problem/11066