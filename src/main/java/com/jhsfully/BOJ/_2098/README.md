### 2098번 : 외판원 순회 [GOLD1]

### 결과
- 시도횟수: 6회 (메모리 초과 2회, 시간초과 1회, 틀렸습니다 1회)
- 언어: Java8
- 메모리: 17912 KB
- 시간: 184 ms

### 문제 접근 및 풀이과정
- 문제를 보고 바로 생각난 알고리즘은 다익스트라 알고리즘 이었습니다.
- 하지만, 해당 문제는 반드시 모든 정점을 한 번씩 지나가야 하고, 마지막은 시작지점과 일치해야 하므로, 이와 다르다는 것을 알았습니다.
- 최단 거리를 구하는 것은 맞지만, 모든 정점을 순환하고 자기 자신까지 돌아오는 조건이 추가로 붙은 것이었습니다.
- 그래서, 지나온 정점을 확인하는 부분을 효율적으로 체크하기 위해 비트마스킹이 필요하다고 유추할 수 있었습니다.
- Level탐색을 수행하는 BFS를 사용하여, 문제를 풀었지만, 메모리 초과로 실패하였습니다.
- BFS는 다음단계로 나가기 위한 정점은 큐에 계속 쌓으면서 보관하므로, 깊이가 깊어질수록, 큐에는 수많은 데이터가 쌓인다는 단점이 존재합니다.
- 어차피 해당 문제는 모든 경우를 탐색해야하므로, DFS와 DP를 사용하는 방식으로 접근하기로 하였습니다.
- DFS를 수행하면서, DP 배열을 참고하여, 지금 위치에서 목적지로 가능 거리 비용이, 더 효율적이면 진행하고 아니면, 진행하지 않은 방식으로 수행하였습니다.
- 하지만, 불필요한 계산이 너무나도 많이 일어났었는지, 이번에는 시간초과가 발생하였습니다.
- 시간초과가 났다는 것은 DP를 효율적으로 저장하지 못하고, 사용하지 못한다는 사실을 방증합니다.
- 검색을 통해 알아보니, BFS를 사용한 DP는 Bottom-UP 방식의 DP라, 현재 상태에 올 수 있는 최적의 값을 저장하면 되지만,
- DFS는 애초부터 결과로부터 시작까지의 역연산을 수행하기 위해 수행하는 방법이므로, 현재 상태에 올 수 있는 최적의 값을 저장하는 것이 아닌,
- 현재의 DP 값에는 미래에 나올 결론에 대한 최적의 값을 저장해야 합니다.
- BFS는 조건에 부합하다면, DP에 현 상태에 대한 최적의 값을 정하지만,
- DFS는 당장에 조건이 부합한지 알 수 없기에, DP에 현재 DP의 값과, 미래에 나올 수 있는 최적의 값(DFS수행 이후 값)을 비교하여
- 최적의 값을 산출하여 저장해야 합니다. 즉, 시작할 떄, DP에 처음으로 저장되는 값이 곧 추후에 연산이 끝나면 정답으로 리턴되게 되는 것입니다.
- DFS알고리즘에서 BFS DP와 같이 현재 상태에 대한 최적의 값을 저장하게 된다면, DP값은 매번 최적의 경로를 찾을 때마다 갱신되고,
- 이는 어느 정도 어느 정도는 추후에 재사용될 가능성이 존재하지만, 결국에 최초에 구해진 DP값 그 자체가 최적이라는 보장이 없어
- 구해진 DP값이 매번 재갱신되어 DP의 역할 제대로 수행할 수 없게 됩니다.
- BFS의 경우는 매번 가는 선택지가 최적이라는 것이 보장되므로, 이렇게 매번 현상태의 최적의 값을 갱신해도, 재갱신 되지 않습니다.
- DFS는 한 길만 끝까지 파고드는데, 이 방식이 옳은 경우라면, 최적이지만, 수많은 경로 중에서 옳지 않을 확률이 너무 높으므로,
- 결국 DFS에서의 DP는 거의 높은 확률로 수없이 갱신 될 확률이 높습니다. 하지만, 미래의 최적의 결과를 저장하는 관점에서 본다면,
- DFS는 어떤 루트를 지나갈 때, 이미 해당 루트에 대한 미래 결과를 계산한 DP값이 있다는 이를 바로 재활용 할 수 있게 됩니다.
- 이는 기저 케이스로 부터 시작된 최적의 값 갱신된 DP값으로 추후에 갱신되지 않습니다.
- 따라서, DFS에서 DP를 사용할 때는 BFS처럼 현상태로 올 수 있는 최적의 값을 갱신하는 것이 아닌, 현상태에서 미래의 끝에 도달했을 떄,
- 나올 수 있는 경우의 최적의 값을 저장해야 합니다. 이렇게 되면, DP의 갱신이 한 번씩만 일어나고, 재사용 횟수를 획기적으로 높일 수 있습니다.

### 문제
외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.

1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.

각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.

N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 도시의 수 N이 주어진다. (2 ≤ N ≤ 16) 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다.

항상 순회할 수 있는 경우만 입력으로 주어진다.

### 출력
첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.