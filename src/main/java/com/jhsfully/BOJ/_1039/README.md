### 1039번: 교환 [GOLD2]

### 결과
- 시도횟수 : 2회
- 언어: Java8
- 메모리: 23160 KB
- 시간: 340 ms

### 풀이 방법
- BFS를 통한 레벨 탐색으로 문제를 풀었습니다.
- M의 최대 자릿수는 1,000,000으로 7자리 지만, 실제로는 1,000,000은 스왑이 불가능한 숫자이므로, 999,999까지 6자리로 생각하였습니다.
- K는 최대 10번까지 스왑이 진행되므로, 한번 스왑되는데 N^2 의 경우의 수가 발생되고 이것이 K번 중첩되어, (N^2)^K 의 시간복잡도가 형성됩니다.
- 최악의 경우에 대입하면, 36^10 의 근접한 경우의 수가 발생되므로, 이는 당연히 엄청큰 수이므로 컴퓨터가 연산하기 힘들어집니다.
- 하지만, N의 값이 최대 1,000,000이 올 수 있다는 점은, 생성될 수 있는 숫자는 1,000,000 개만 해당된다는 것입니다.
- 중복제거를 수행하게 되면, 36^10 에서, 1,000,000 * K 만큼이 최악이 되므로, 충분히 완전탐색으로 문제해결이 가능하다는 결론을 내렸습니다.
- 레벨 탐색 변수로 Queue, 중복제거로 Set으로 사용하고, 중간에 Swap을 위해서는 char array를 사용하여, 문제를 풀어냈습니다.
- 탐색하다가, set에 값이 빈 경우는 더 이상 swap이 불가능한 경우로써, -1을 출력하고, 그게 아니면, stream()연산을 통해 최댓값을 출력하였습니다.

### 문제
0으로 시작하지 않는 정수 N이 주어진다. 이때, M을 정수 N의 자릿수라고 했을 때, 다음과 같은 연산을 K번 수행한다.

1 ≤ i < j ≤ M인 i와 j를 고른다. 그 다음, i번 위치의 숫자와 j번 위치의 숫자를 바꾼다. 이때, 바꾼 수가 0으로 시작하면 안 된다.

위의 연산을 K번 했을 때, 나올 수 있는 수의 최댓값을 구하는 프로그램을 작성하시오.

### 입력
첫째 줄에 정수 N과 K가 주어진다. N은 1,000,000보다 작거나 같은 자연수이고, K는 10보다 작거나 같은 자연수이다.

### 출력
첫째 줄에 문제에 주어진 연산을 K번 했을 때, 만들 수 있는 가장 큰 수를 출력한다. 만약 연산을 K번 할 수 없으면 -1을 출력한다.