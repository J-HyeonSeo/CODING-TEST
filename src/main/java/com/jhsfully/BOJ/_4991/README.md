### 4991번 : 로봇 청소기 [GOLD1]

### 문제 유형
- BFS, 순열, 격자 문제

### 결과
- 시도횟수: 3회 (1, 2회 => 틀렸습니다)
- 언어: Java8
- 메모리: 40544 KB
- 시간: 1508 ms

### 문제 접근 방법 및 풀이
- 격자 문제 중에서도, 처리해야 할 부분이 상당히 많고 까다로운 문제였습니다.
- 초반에는 이 문제를 Greedy하게 풀 수 있지 않을까 했지만, 코드를 작성하면서, 해당 문제는 최적의 해를 보장하는 탐욕적인 방법이 존재하지 않았습니다.
- 왜냐하면, Greedy는 매번 최고의 선택을 하는데, 해당 문제는 당장 가까운 곳을 청소해도, 그 다음에는 먼 장소로 청소하러 가는 경우가 발생할 수 있기 때문입니다.
- 이런 이유로 해당 문제는 BFS를 통한 완전탐색으로 풀어야 함을 알 수 있었습니다.
- 하지만, 모든 경우를 탐색하면서, BFS로 푸는 것은 누가봐도 시간초과가 일어납니다.
- 목적지까지 이동하는 곳이 10개나 가능하기에, 즉 대략 10^10 정도의 시간 복잡도에다가, BFS탐색에 대한 시간복잡도 20*20 만큼을 매번 수행해야 합니다.
- 하지만, 여기서 BFS탐색을 수행할 때, 같은 곳을 계속 계산한다는 점이 존재합니다. 그래서 거리부분을 일단 한 번에 구하고,
- 목적지까지 이동하는 경우를 추가적으로 탐색하는 방안을 구상하였습니다.
- 최대 11개의 그룹으로 나누어서, 좌표 간의 이동을 그룹간의 이동으로 치환해서 문제를 단순화하여 풀었습니다.
- 각 그룹별로, 다른 그룹으로 이동하는데 갈 수 있는 최단 거리를 구하고,
- 시작 그룹부터, 시뮬레이션을 통해서, 최단 거리를 산출해내도록 알고리즘을 구성하였습니다.
- 하지만, 시뮬레이션을 수행하는 시간복잡도가, 10^10이 나오게 됩니다. 이는 일반적으로 for문을 full로 돌리면 나오는 경우입니다.
- 하지만, 해당 문제는 한 번 선택한 경로는 다시 선택하지 않아도 되므로, 이를 10^10에서 10! 로 줄일 수 있는 방법이 존재합니다.
- 여러 방법이 있겠지만, 저는 순열 알고리즘을 사용해서, 앞으로 선택할 경로를 swap해가면서 10! 경우로 수렴할 수 있도록 구현하였습니다.
- 단순한 for문으로 구성하면, 10^10, 순열 알고리즘을 통해 필요없는 부분을 탐색하지 않는 방향으로 구성하면, 10!으로 수렴할 수 있습니다.
- 물론 visited를 두고, 체크해도, 10^10의 까지의 시간복잡도는 아니지만, swap을 통해 진행한 알고리즘보다, 필요하지 않는 부분까지 탐색하기에,
- 효율성이 더 좋지 않는 건 사실입니다.
- 최종적으로는 BFS탐색 20 * 20 * 10 = 4000번에 + 10! 횟수를 더해서, 안정적인 횟수로 시간복잡도를 맞출 수 있었습니다.

### 문제
https://www.acmicpc.net/problem/4991